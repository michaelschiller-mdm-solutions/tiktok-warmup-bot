# 4 Build Thread Classification System

## Description

Create logic to classify conversations as basis/premium and match adverts based on the verified API response structure. This system processes the `normalGroup` and `premiumGroup` data from the getThreads API response.

## Status History

| Timestamp | Event Type | From Status | To Status | Details | User |
|-----------|------------|-------------|-----------|---------|------|
| 2025-01-06 15:00:00 | Created | N/A | not_started | Task created | System |

## Requirements

Implement thread classification based on verified API response structure:
- Process `normalGroup` (basis chats) and `premiumGroup` (premium chats) from getThreads response
- Match `titleText` from basis chats to user-configured adverts
- Handle the `mailboxOwnerId` field for user validation
- Track unread counts: `unreadMailboxMessagesNormal` and `unreadMailboxMessagesPremium`

_Requirements: 17 (basis vs premium chat distinction), 18 (advert content and personalities)_

## Implementation Plan

### 1. Create Thread Classifier
Based on verified API response structure:
```javascript
class ThreadClassifier {
  constructor() {
    this.configuredAdverts = new Map(); // title -> advert config
  }
  
  processThreadsResponse(apiResponse) {
    const result = {
      basisThreads: [],
      premiumThreads: [],
      unreadCounts: {
        normal: apiResponse.data.piggyBackData?.unreadMailboxMessagesNormal || 0,
        premium: apiResponse.data.piggyBackData?.unreadMailboxMessagesPremium || 0
      },
      mailboxOwnerId: apiResponse.data.data.mailboxOwnerId
    };
    
    // Process normalGroup (basis chats)
    if (apiResponse.data.data.normalGroup?.results) {
      result.basisThreads = apiResponse.data.data.normalGroup.results.map(thread => 
        this.createThreadObject(thread, 'basis')
      );
    }
    
    // Process premiumGroup (premium chats)  
    if (apiResponse.data.data.premiumGroup?.results) {
      result.premiumThreads = apiResponse.data.data.premiumGroup.results.map(thread => 
        this.createThreadObject(thread, 'premium')
      );
    }
    
    return result;
  }
}
```

### 2. Implement Thread Object Creation
Using exact field names from API response:
```javascript
createThreadObject(threadData, chatType) {
  return {
    threadId: threadData.threadId,
    chatType: chatType, // 'basis' or 'premium'
    
    // Participant information
    otherParticipantName: threadData.otherParticipantName,
    otherParticipantProfileUrl: threadData.otherParticipantProfileUrl,
    otherParticipantId: this.extractUserIdFromUrl(threadData.otherParticipantProfileUrl),
    otherParticipantInactive: threadData.otherParticipantInactive,
    
    // Message information
    lastMessageHtml: threadData.lastMessageHtml,
    lastMessageId: threadData.lastMessageId,
    lastMessageByMe: threadData.lastMessageByMe,
    lastMessageDate: threadData.lastMessageDate,
    lastMessageHasSharedImages: threadData.lastMessageHasSharedImages,
    
    // Count information
    numberOfTotalMessages: threadData.numberOfTotalMessages,
    numberOfUnreadMessages: threadData.numberOfUnreadMessages,
    
    // Basis-specific fields
    titleText: threadData.titleText, // Advert title for basis chats
    advertMatch: chatType === 'basis' ? this.matchAdvert(threadData.titleText) : null,
    
    // Calculated fields
    isNewChat: this.isNewChat(threadData.numberOfUnreadMessages, threadData.numberOfTotalMessages),
    needsResponse: threadData.numberOfUnreadMessages > 0 && !threadData.lastMessageByMe
  };
}
```

### 3. Implement Advert Matching
Based on the `titleText` field from basis chats:
```javascript
class AdvertMatcher {
  constructor(userAdverts) {
    this.userAdverts = userAdverts; // From user configuration
  }
  
  matchAdvert(titleText) {
    if (!titleText) return null;
    
    // Exact match first
    const exactMatch = this.userAdverts.find(advert => 
      advert.title === titleText
    );
    
    if (exactMatch) {
      return {
        ...exactMatch,
        matchType: 'exact',
        confidence: 1.0
      };
    }
    
    // Fuzzy matching for similar titles
    const fuzzyMatch = this.findBestFuzzyMatch(titleText);
    if (fuzzyMatch && fuzzyMatch.confidence > 0.8) {
      return fuzzyMatch;
    }
    
    return {
      title: titleText,
      matchType: 'unmatched',
      confidence: 0,
      personality: 'default' // Use default personality
    };
  }
}
```

### 4. Implement New Chat Detection
Based on verified logic from API testing:
```javascript
isNewChat(unreadCount, totalCount) {
  // New chat when unread count equals total count and both equal 1
  return unreadCount === totalCount && totalCount === 1;
}
```

### 5. Add User ID Extraction
From verified profile URL pattern:
```javascript
extractUserIdFromUrl(profileUrl) {
  // Pattern: https://www.markt.de/username/userId,{ID}/profile.htm
  const match = profileUrl.match(/userId,(\d+)/);
  return match ? match[1] : null;
}
```

### 6. Create Priority Scoring
```javascript
calculatePriority(thread) {
  let priority = 0;
  
  // Higher priority for new chats
  if (thread.isNewChat) priority += 100;
  
  // Higher priority for unread messages
  priority += thread.numberOfUnreadMessages * 10;
  
  // Higher priority for recent messages
  const messageAge = Date.now() - parseInt(thread.lastMessageDate.epochTime);
  const hoursOld = messageAge / (1000 * 60 * 60);
  priority += Math.max(0, 50 - hoursOld);
  
  // Higher priority for basis chats with matched adverts
  if (thread.chatType === 'basis' && thread.advertMatch?.matchType === 'exact') {
    priority += 25;
  }
  
  return priority;
}
```

## Test Plan

### Success Criteria
- Correctly processes both normalGroup and premiumGroup from API response
- Accurately extracts all thread data using exact field names
- Properly matches advert titles to user configurations
- Correctly identifies new chats using verified logic
- Calculates meaningful priority scores for conversation processing

### Test Scenarios
1. **API Response Processing**: Use actual getThreads response data
2. **Thread Classification**: Verify basis vs premium classification
3. **Advert Matching**: Test with known advert titles from API data
4. **New Chat Detection**: Test with various unread/total count combinations
5. **User ID Extraction**: Test with actual profile URLs from API responses

### Test Data (From Verified API Responses)
```javascript
// Basis thread example
{
  threadId: "2192657861",
  titleText: "Na du erb√§rmliches ZahIschwein, schon wieder hier?",
  otherParticipantName: "Tarantino96",
  otherParticipantProfileUrl: "https://www.markt.de/tarantino96/userId,24766335/profile.htm",
  numberOfUnreadMessages: 1,
  numberOfTotalMessages: 3,
  lastMessageByMe: false
}

// Premium thread example  
{
  threadId: "2193521669",
  titleText: "Profilnachricht", // or null for premium
  otherParticipantName: "Anna-Fae",
  otherParticipantProfileUrl: "https://www.markt.de/anna+fae/userId,39793847/profile.htm",
  numberOfUnreadMessages: 0,
  numberOfTotalMessages: 14,
  lastMessageByMe: true
}
```

## Verification

- [ ] Processes normalGroup and premiumGroup correctly from API response
- [ ] Extracts all thread fields using exact API field names
- [ ] Correctly identifies basis vs premium chat types
- [ ] Matches advert titles to user configurations
- [ ] Detects new chats using verified logic (unread === total === 1)
- [ ] Extracts user IDs from profile URLs correctly
- [ ] Calculates priority scores for conversation processing
- [ ] Handles missing or null fields gracefully

## Files Modified

- `marktde-ai-chat-bot/src/classification/ThreadClassifier.js` (new)
- `marktde-ai-chat-bot/src/classification/AdvertMatcher.js` (new)
- `marktde-ai-chat-bot/src/utils/PriorityCalculator.js` (new)
- `marktde-ai-chat-bot/src/utils/UserIdExtractor.js` (update)

[Back to task list](./tasks.md)