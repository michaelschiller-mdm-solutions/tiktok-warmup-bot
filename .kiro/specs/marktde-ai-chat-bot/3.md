# 3 Create Conversation Data Models

## Description

Implement data structures for threads, messages, and conversation state based on the verified API response formats. These models will provide a clean interface for the bot to work with markt.de data.

## Status History

| Timestamp | Event Type | From Status | To Status | Details | User |
|-----------|------------|-------------|-----------|---------|------|
| 2025-01-06 15:00:00 | Created | N/A | not_started | Task created | System |

## Requirements

Create data models that accurately represent the API response structures and provide utility methods for conversation management:
- Thread model with participant and advert information
- Message model with metadata and content
- Conversation state tracking
- Chat type classification logic

_Requirements: 4 (conversation data persistence), 17 (basis vs premium chat distinction)_

## Implementation Plan

### 1. Create Thread Model
Based on verified API response structure:
```javascript
class Thread {
  constructor(threadData, groupType) {
    this.threadId = threadData.threadId;
    this.otherParticipantId = this.extractUserIdFromUrl(threadData.otherParticipantProfileUrl);
    this.otherParticipantName = threadData.otherParticipantName;
    this.chatType = groupType; // 'basis' or 'premium'
    this.advertTitle = threadData.titleText; // For basis chats
    this.unreadCount = threadData.numberOfUnreadMessages;
    this.totalMessages = threadData.numberOfTotalMessages;
    this.lastMessageByMe = threadData.lastMessageByMe;
    this.lastMessageDate = threadData.lastMessageDate;
    this.isNewChat = this.calculateIsNewChat();
  }
  
  calculateIsNewChat() {
    return this.unreadCount === this.totalMessages && this.totalMessages === 1;
  }
  
  extractUserIdFromUrl(profileUrl) {
    const match = profileUrl.match(/userId,(\d+)/);
    return match ? match[1] : null;
  }
}
```

### 2. Create Message Model
```javascript
class Message {
  constructor(messageData) {
    this.messageId = messageData.messageId;
    this.messageText = messageData.messageText?.plain || '';
    this.sentFromMe = messageData.sentFromMe;
    this.seenByOther = messageData.seenByOther;
    this.messageDate = messageData.messageDate;
    this.sharedImages = messageData.sharedImages || [];
    this.hasImages = this.sharedImages.length > 0;
  }
  
  isTextOnly() {
    return this.messageText && !this.hasImages;
  }
  
  isImageOnly() {
    return !this.messageText && this.hasImages;
  }
}
```

### 3. Create Conversation State Model
```javascript
class ConversationState {
  constructor(threadId) {
    this.threadId = threadId;
    this.phase = 'initial'; // initial, engagement, cta, converted, post-conversion
    this.startTime = Date.now();
    this.totalMessageExchanges = 0;
    this.currentLoopExchanges = 0;
    this.phaseStartTime = Date.now();
    this.lastMessageType = null;
    this.lastObjection = null;
    this.hasSharedCTA = false;
    this.hasConverted = false;
    this.isExcluded = false;
    this.lastUpdate = Date.now();
  }
  
  updatePhase(newPhase) {
    this.phase = newPhase;
    this.phaseStartTime = Date.now();
    this.currentLoopExchanges = 0;
    this.lastUpdate = Date.now();
  }
  
  incrementMessageCount() {
    this.totalMessageExchanges++;
    this.currentLoopExchanges++;
    this.lastUpdate = Date.now();
  }
}
```

### 4. Create Conversation Manager
```javascript
class ConversationManager {
  constructor() {
    this.conversations = new Map(); // threadId -> ConversationState
    this.threads = new Map(); // threadId -> Thread
    this.messages = new Map(); // threadId -> Message[]
  }
  
  addThread(threadData, groupType) {
    const thread = new Thread(threadData, groupType);
    this.threads.set(thread.threadId, thread);
    
    if (!this.conversations.has(thread.threadId)) {
      this.conversations.set(thread.threadId, new ConversationState(thread.threadId));
    }
    
    return thread;
  }
  
  addMessages(threadId, messagesData) {
    const messages = messagesData.map(msgData => new Message(msgData));
    this.messages.set(threadId, messages);
    return messages;
  }
  
  getConversationContext(threadId) {
    return {
      thread: this.threads.get(threadId),
      state: this.conversations.get(threadId),
      messages: this.messages.get(threadId) || []
    };
  }
}
```

### 5. Add Advert Matching Logic
```javascript
class AdvertMatcher {
  constructor(configuredAdverts) {
    this.configuredAdverts = configuredAdverts; // From user configuration
  }
  
  matchAdvertToThread(thread) {
    if (thread.chatType !== 'basis' || !thread.advertTitle) {
      return null;
    }
    
    // Exact match first
    const exactMatch = this.configuredAdverts.find(
      advert => advert.title === thread.advertTitle
    );
    
    if (exactMatch) {
      return exactMatch;
    }
    
    // Fuzzy matching for similar titles
    return this.findBestMatch(thread.advertTitle);
  }
  
  findBestMatch(title) {
    // Simple similarity matching - can be enhanced later
    let bestMatch = null;
    let bestScore = 0;
    
    for (const advert of this.configuredAdverts) {
      const score = this.calculateSimilarity(title, advert.title);
      if (score > bestScore && score > 0.8) {
        bestScore = score;
        bestMatch = advert;
      }
    }
    
    return bestMatch;
  }
  
  calculateSimilarity(str1, str2) {
    // Simple Levenshtein distance-based similarity
    const longer = str1.length > str2.length ? str1 : str2;
    const shorter = str1.length > str2.length ? str2 : str1;
    
    if (longer.length === 0) return 1.0;
    
    const distance = this.levenshteinDistance(longer, shorter);
    return (longer.length - distance) / longer.length;
  }
}
```

## Test Plan

### Success Criteria
- Thread model correctly parses API response data
- Message model handles both text and image messages
- Conversation state tracks phases and metrics accurately
- Advert matching correctly identifies basis chat contexts
- All models provide clean interfaces for bot operations

### Test Scenarios
1. **Thread Creation**: Create Thread objects from API response data
2. **Message Parsing**: Parse message arrays from getMessages responses
3. **Chat Classification**: Verify basis vs premium classification
4. **New Chat Detection**: Test isNewChat logic with various scenarios
5. **Advert Matching**: Test exact and fuzzy matching for advert titles
6. **State Management**: Test conversation state updates and persistence

### Test Data
Use verified API response data:
- Anna-Fae thread (premium): threadId `2193521669`
- Basis threads with advert titles from getThreads response
- Message arrays with mixed text/image content

## Verification

- [ ] Thread model correctly extracts all participant data
- [ ] Message model handles text-only, image-only, and mixed messages
- [ ] Chat type classification works for both basis and premium
- [ ] New chat detection logic matches expected behavior
- [ ] Conversation state tracking updates correctly
- [ ] Advert matching finds correct configurations for basis chats
- [ ] All models serialize/deserialize for storage
- [ ] User ID extraction works from profile URLs

## Files Modified

- `marktde-ai-chat-bot/src/models/Thread.js` (new)
- `marktde-ai-chat-bot/src/models/Message.js` (new)
- `marktde-ai-chat-bot/src/models/ConversationState.js` (new)
- `marktde-ai-chat-bot/src/managers/ConversationManager.js` (new)
- `marktde-ai-chat-bot/src/utils/AdvertMatcher.js` (new)

[Back to task list](./tasks.md)