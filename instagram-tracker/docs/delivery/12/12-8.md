# [12-8] Emergency Content Injection System

## Description

Build comprehensive emergency content injection system that can interrupt normal scheduling with sophisticated conflict resolution capabilities. This system allows immediate injection of urgent content with options to pause current sprints, handle location conflicts, and maintain system integrity while providing maximum flexibility for emergency responses.

## Status History

| Timestamp | Event Type | From Status | To Status | Details | User |
|-----------|------------|-------------|-----------|---------|------|
| 2024-12-20 00:30:00 | Created | N/A | InProgress | Task created to implement emergency content injection system | AI_Agent |
| 2024-12-20 01:00:00 | Implementation | InProgress | Review | Core emergency content services and API endpoints implemented | AI_Agent |
| 2024-12-20 01:05:00 | Complete | Review | Done | Emergency content injection system fully implemented and integrated | AI_Agent |

## Requirements

### Core Emergency Content Features

1. **Immediate Content Injection**:
   - Inject emergency content that posts immediately or as next item
   - Support all content types (story, post, highlight)
   - Override normal queue scheduling with priority insertion
   - Emergency content bypasses normal delay restrictions

2. **Conflict Resolution Strategies**:
   - **Pause Sprints**: Temporarily pause active sprints for emergency content
   - **Post Alongside**: Continue normal sprints while inserting emergency content
   - **Override Conflicts**: Force post emergency content despite location/theme conflicts
   - **Skip Conflicted Accounts**: Only assign emergency content to compatible accounts

3. **Location and Theme Conflict Handling**:
   - Detect location conflicts (Jamaica content during Germany sprint)
   - Identify theme conflicts (work content during vacation sprint)
   - Provide clear warnings about conflicts with override options
   - Track conflict resolutions for audit purposes

4. **Queue Management Integration**:
   - Insert emergency content into existing content queues
   - Adjust existing queue timestamps to accommodate emergency content
   - Extend sprint cooldowns when emergency content interrupts sprints
   - Maintain queue integrity and chronological ordering

### Advanced Features

1. **Emergency Content Categorization**:
   - **Critical**: Must post immediately (breaking news, urgent responses)
   - **High Priority**: Post as next item in queue
   - **Standard Emergency**: Insert with minimal delay but respect basic conflicts

2. **Bulk Emergency Operations**:
   - Apply emergency content to multiple accounts simultaneously
   - Different strategies per account based on current state
   - Batch conflict resolution with summary reporting

3. **Emergency Analytics and Tracking**:
   - Track emergency content performance separately
   - Monitor conflict resolution outcomes
   - Analyze impact on regular content scheduling
   - Generate emergency content usage reports

## Implementation Plan

### Phase 1: Core Emergency Services

1. **Emergency Content Service**:
   - Validate emergency content compatibility
   - Detect account conflicts (location, theme, timing)
   - Generate conflict resolution recommendations
   - Execute emergency content injection with chosen strategy

2. **Conflict Detection Engine**:
   - Location conflict detection (current vs emergency content location)
   - Sprint blocking rule conflicts
   - Theme compatibility analysis
   - Timing conflict identification

### Phase 2: Queue Manipulation System

3. **Emergency Queue Service**:
   - Insert emergency content at appropriate queue positions
   - Adjust existing queue item timestamps
   - Handle sprint pausing and resuming
   - Maintain queue integrity during emergency operations

4. **State Management Updates**:
   - Update account content state for emergency content
   - Track emergency content timestamps
   - Manage cooldown extensions
   - Log all emergency actions for audit trail

### Phase 3: API Integration

5. **Emergency Content API Endpoints**:
   - Emergency content injection endpoints
   - Conflict preview and resolution endpoints
   - Emergency content status and tracking
   - Bulk emergency operations

## Technical Implementation

### Type Definitions

```typescript
export interface EmergencyContent {
  id?: number;
  file_path: string;
  file_name: string;
  caption?: string;
  content_type: 'story' | 'post' | 'highlight';
  priority: 'critical' | 'high' | 'standard';
  location_context?: string;
  theme_context?: string;
  post_immediately: boolean;
}

export interface EmergencyInjectionRequest {
  emergency_content: EmergencyContent;
  target_account_ids?: number[];
  target_all_accounts?: boolean;
  conflict_strategy: 'pause_sprints' | 'post_alongside' | 'override_conflicts' | 'skip_conflicted';
  cooldown_extension_hours?: number;
  scheduled_time?: Date;
}

export interface ConflictAnalysis {
  account_id: number;
  has_conflicts: boolean;
  location_conflicts: LocationConflict[];
  sprint_conflicts: SprintConflict[];
  theme_conflicts: ThemeConflict[];
  recommended_strategy: ConflictStrategy;
  can_proceed: boolean;
}

export interface EmergencyInjectionResult {
  successful_injections: SuccessfulInjection[];
  failed_injections: FailedInjection[];
  conflicts_resolved: ConflictResolution[];
  queue_adjustments: QueueAdjustment[];
  total_accounts_affected: number;
  summary: string;
}

export interface LocationConflict {
  type: 'location_mismatch';
  current_location: string;
  emergency_location: string;
  severity: 'warning' | 'error';
  resolution_options: string[];
}

export interface SprintConflict {
  type: 'sprint_blocking' | 'theme_mismatch';
  active_sprint_id: number;
  sprint_name: string;
  conflict_reason: string;
  resolution_options: string[];
}
```

### Core Business Logic

#### Emergency Content Service

```typescript
class EmergencyContentService {
  async injectEmergencyContent(request: EmergencyInjectionRequest): Promise<EmergencyInjectionResult> {
    // 1. Validate emergency content
    await this.validateEmergencyContent(request.emergency_content);
    
    // 2. Determine target accounts
    const targetAccounts = await this.getTargetAccounts(request);
    
    // 3. Analyze conflicts for each account
    const conflictAnalyses = await this.analyzeConflicts(
      request.emergency_content, 
      targetAccounts
    );
    
    // 4. Execute injection strategy
    const results = await this.executeInjectionStrategy(
      request, 
      conflictAnalyses
    );
    
    // 5. Update analytics and tracking
    await this.trackEmergencyInjection(request, results);
    
    return results;
  }

  private async analyzeConflicts(
    emergencyContent: EmergencyContent,
    accounts: Account[]
  ): Promise<ConflictAnalysis[]> {
    const analyses: ConflictAnalysis[] = [];
    
    for (const account of accounts) {
      const accountState = await this.getAccountContentState(account.id);
      const activeSprintss = await this.getActiveSprintss(account.id);
      
      const conflicts: ConflictAnalysis = {
        account_id: account.id,
        has_conflicts: false,
        location_conflicts: [],
        sprint_conflicts: [],
        theme_conflicts: [],
        recommended_strategy: 'post_alongside',
        can_proceed: true
      };
      
      // Check location conflicts
      if (emergencyContent.location_context && 
          accountState.current_location !== emergencyContent.location_context) {
        conflicts.location_conflicts.push({
          type: 'location_mismatch',
          current_location: accountState.current_location,
          emergency_location: emergencyContent.location_context,
          severity: 'warning',
          resolution_options: ['override_location', 'skip_account', 'pause_sprints']
        });
        conflicts.has_conflicts = true;
      }
      
      // Check sprint blocking conflicts
      for (const sprint of activeSprintss) {
        if (this.hasSprintConflict(sprint, emergencyContent)) {
          conflicts.sprint_conflicts.push({
            type: 'sprint_blocking',
            active_sprint_id: sprint.id,
            sprint_name: sprint.name,
            conflict_reason: `Sprint location ${sprint.location} conflicts with emergency content`,
            resolution_options: ['pause_sprint', 'override_conflict', 'skip_account']
          });
          conflicts.has_conflicts = true;
        }
      }
      
      // Determine recommended strategy
      if (conflicts.has_conflicts) {
        conflicts.recommended_strategy = this.determineRecommendedStrategy(conflicts);
      }
      
      analyses.push(conflicts);
    }
    
    return analyses;
  }

  private async executeInjectionStrategy(
    request: EmergencyInjectionRequest,
    analyses: ConflictAnalysis[]
  ): Promise<EmergencyInjectionResult> {
    const results: EmergencyInjectionResult = {
      successful_injections: [],
      failed_injections: [],
      conflicts_resolved: [],
      queue_adjustments: [],
      total_accounts_affected: 0,
      summary: ''
    };
    
    for (const analysis of analyses) {
      try {
        if (!analysis.can_proceed && request.conflict_strategy === 'skip_conflicted') {
          continue; // Skip accounts with conflicts
        }
        
        const injection = await this.performInjection(request, analysis);
        results.successful_injections.push(injection);
        results.total_accounts_affected++;
        
      } catch (error) {
        results.failed_injections.push({
          account_id: analysis.account_id,
          error: error.message,
          conflicts: analysis
        });
      }
    }
    
    results.summary = this.generateInjectionSummary(results);
    return results;
  }
}
```

#### Emergency Queue Management

```typescript
class EmergencyQueueService {
  async insertEmergencyContent(
    accountId: number,
    emergencyContent: EmergencyContent,
    strategy: ConflictStrategy
  ): Promise<QueueAdjustment[]> {
    const adjustments: QueueAdjustment[] = [];
    
    // 1. Get current queue for account
    const currentQueue = await this.queueManagementService.getAccountQueue(accountId);
    
    // 2. Determine insertion point
    const insertionTime = emergencyContent.post_immediately 
      ? new Date() 
      : this.calculateInsertionTime(currentQueue, emergencyContent.priority);
    
    // 3. Handle strategy-specific adjustments
    switch (strategy) {
      case 'pause_sprints':
        adjustments.push(...await this.pauseActiveSprintss(accountId, insertionTime));
        break;
        
      case 'post_alongside':
        // Insert without affecting existing content
        break;
        
      case 'override_conflicts':
        adjustments.push(...await this.overrideConflicts(accountId, insertionTime));
        break;
    }
    
    // 4. Insert emergency content into queue
    await this.insertIntoQueue(accountId, emergencyContent, insertionTime);
    
    // 5. Adjust subsequent queue items if necessary
    if (strategy === 'pause_sprints') {
      adjustments.push(...await this.adjustSubsequentItems(accountId, insertionTime));
    }
    
    return adjustments;
  }

  private async pauseActiveSprintss(
    accountId: number, 
    pauseTime: Date
  ): Promise<QueueAdjustment[]> {
    const adjustments: QueueAdjustment[] = [];
    
    // Pause all active sprint assignments
    const activeAssignments = await this.sprintAssignmentService.getActiveAssignments(accountId);
    
    for (const assignment of activeAssignments) {
      await this.sprintAssignmentService.pauseAssignment(assignment.id);
      
      adjustments.push({
        type: 'sprint_paused',
        assignment_id: assignment.id,
        original_status: assignment.status,
        new_status: 'paused',
        pause_time: pauseTime
      });
    }
    
    return adjustments;
  }

  private calculateInsertionTime(
    currentQueue: QueueItem[],
    priority: EmergencyPriority
  ): Date {
    const now = new Date();
    
    switch (priority) {
      case 'critical':
        return now; // Post immediately
        
      case 'high':
        // Post as next item
        const nextItem = currentQueue.find(item => 
          item.scheduled_time > now && item.status === 'queued'
        );
        return nextItem ? new Date(nextItem.scheduled_time.getTime() - 60000) : now;
        
      case 'standard':
        // Insert with minimal delay
        return new Date(now.getTime() + 3600000); // 1 hour from now
        
      default:
        return now;
    }
  }
}
```

## Test Plan

### Emergency Injection Testing

1. **Basic Injection**:
   - Test immediate emergency content posting
   - Test priority-based queue insertion
   - Test content type validation
   - Test account targeting (specific vs all accounts)

2. **Conflict Detection**:
   - Test location conflict detection
   - Test sprint blocking conflict detection
   - Test theme conflict identification
   - Test conflict severity assessment

3. **Strategy Execution**:
   - Test sprint pausing strategy
   - Test post alongside strategy
   - Test conflict override strategy
   - Test skip conflicted accounts strategy

### Queue Management Testing

1. **Queue Integrity**:
   - Test queue ordering after emergency insertion
   - Test timestamp adjustments for existing items
   - Test queue state consistency
   - Test concurrent emergency insertions

2. **State Management**:
   - Test account state updates during emergency
   - Test cooldown extension calculations
   - Test sprint pause/resume functionality
   - Test emergency content tracking

### Integration Testing

1. **API Integration**:
   - Test all emergency content endpoints
   - Test bulk emergency operations
   - Test conflict preview functionality
   - Test emergency analytics endpoints

2. **System Integration**:
   - Test integration with existing queue system
   - Test integration with sprint assignment system
   - Test integration with content management system
   - Test emergency content with bot API

## Verification

### Core Functionality
- [ ] Emergency content can be injected immediately
- [ ] Conflict detection identifies location and sprint conflicts
- [ ] Multiple resolution strategies work correctly
- [ ] Queue integrity maintained during emergency operations
- [ ] Account state properly updated for emergency content

### Conflict Resolution
- [ ] Pause sprints strategy pauses active assignments
- [ ] Post alongside strategy maintains existing schedules
- [ ] Override conflicts strategy posts despite conflicts
- [ ] Skip conflicted accounts strategy filters appropriately
- [ ] Conflict warnings provide clear information

### Queue Management
- [ ] Emergency content inserted at correct queue positions
- [ ] Existing queue items adjusted appropriately
- [ ] Queue ordering maintained after emergency insertion
- [ ] Sprint cooldowns extended correctly
- [ ] Emergency content tracked separately in analytics

## Files Modified

### New Service Files
- **`src/services/EmergencyContentService.ts`**: Core emergency content management
- **`src/services/EmergencyQueueService.ts`**: Queue manipulation for emergency content
- **`src/services/ConflictDetectionService.ts`**: Conflict analysis and resolution

### New API Routes
- **`src/routes/emergencyContent.ts`**: Emergency content injection endpoints

### Type Definitions
- **`src/types/emergencyContent.ts`**: TypeScript interfaces for emergency content

### Updated Files
- **`src/services/QueueManagementService.ts`**: Add emergency content support
- **`src/services/SprintAssignmentService.ts`**: Add pause/resume functionality
- **`src/types/queue.ts`**: Extend with emergency content types

## Success Criteria

✅ **Immediate Injection**: Emergency content can be posted immediately or as next item
✅ **Conflict Detection**: System identifies and reports all types of conflicts
✅ **Strategy Flexibility**: Multiple conflict resolution strategies available
✅ **Queue Integrity**: Emergency operations maintain system consistency
✅ **Analytics Integration**: Emergency content tracked separately from regular content

---

[Back to task list](./tasks.md)